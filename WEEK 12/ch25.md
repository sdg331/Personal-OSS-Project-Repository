# 25. 브랜치 리베이스 (Git Rebase) 학습 정리

## 1. Rebase(리베이스) 개요
### 1.1 정의 및 개념
* **Rebase**: "Re-Base" 즉, **베이스(Base)를 재배치**한다는 의미.
* **Base란?**: 두 브랜치가 갈라져 나온 **공통 조상 커밋**을 말함.
* **목적**: 브랜치의 분기 이력을 남기지 않고, 마치 하나의 줄기에서 작업이 이어진 것처럼 **선형적인(Linear) 히스토리**를 만들기 위함.

### 1.2 왜 사용하는가?
* **3-way Merge의 단점**: 브랜치가 많아지면 병합 커밋(Merge Commit)이 계속 생겨 히스토리가 복잡해짐 (기찻길 처럼 얽힘).
* **Rebase의 장점**: 불필요한 병합 커밋을 제거하고 히스토리를 깔끔한 한 줄로 정렬할 수 있음.

---

## 2. Merge vs Rebase 비교 (핵심!)

| 구분 | 3-way Merge (일반 병합) | Rebase (재배치) |
| :--- | :--- | :--- |
| **동작 방식** | 두 브랜치와 Base를 합쳐 **새로운 병합 커밋** 생성 | 내 브랜치의 Base를 **대상 브랜치의 최신 커밋**으로 변경 |
| **히스토리** | 분기되었다가 다시 합류하는 모양 (Diamond Shape) | 분기 없이 쭉 이어진 일직선 모양 (Linear) |
| **커밋 ID** | 기존 커밋 ID 유지 | **새로운 커밋 ID 부여** (내용은 같지만 다른 커밋이 됨) |
| **장점** | 히스토리의 **진실성** 보존 (언제 병합했는지 알 수 함) | 히스토리의 **가독성** 확보 (깔끔함) |

> ****
> *(Merge는 두 갈래가 합쳐지는 형태, Rebase는 한 줄 뒤에 이어 붙이는 형태)*

---

## 3. [실습] Rebase 수행 과정 (Step-by-Step)

### 3.1 상황 설정 (갈라진 브랜치 만들기)
* **상황**: `main` 브랜치와 `topic` 브랜치가 `1`번 커밋(Base)에서 갈라져서 서로 다른 작업을 진행함.
    * `main`: 1 -> 2 (진행됨)
    * `topic`: 1 -> A -> B (진행됨)

```bash
# 1. 저장소 생성 및 초기화
$ git init grebase
$ cd grebase

# 2. Base 커밋 생성 (1)
$ touch f
$ git add f
$ git commit -m "1"

# 3. topic 브랜치 생성 및 작업 (A, B)
$git switch -c topic$ touch g
$ git add g
$git commit -m "A"$ echo bbb >> g
$ git commit -am "B"

# 4. main 브랜치로 돌아와서 작업 (2)
$ git switch main
$echo 222 >> f$ git commit -am "2"
````

### 3.2 현재 상태 확인 (Graph)

  * 3-way Merge를 해야 할 것 같은 갈라진 상태.

<!-- end list -->

```bash
$ git log --graph --oneline --all
* 6a12b3 (HEAD -> main) 2
| * 7c34d5 (topic) B
| * 5e67f8 A
|/
* 1a23b4 1   <-- 현재 Base
```

### 3.3 Rebase 수행 (핵심 명령어)

  * **원칙**: "나는 `topic` 브랜치를 `main`의 최신 내용 뒤에 붙이겠다."
  * 따라서 반드시 **이동시킬 브랜치(`topic`)로 switch** 한 뒤 명령어를 입력해야 함.


```bash
# 1. topic 브랜치로 이동
$ git switch topic

# 2. Rebase 실행 (Base를 main의 최신 커밋으로 변경)
$ git rebase main
```

**[Rebase 내부 동작 원리]**

1.  Git은 `topic`의 커밋(A, B)을 임시 공간에 보관함.
2.  `topic` 브랜치의 Base를 `main`의 최신 커밋(`2`)으로 변경함.
3.  보관해둔 커밋(A, B)을 하나씩 가져와서 순서대로 적용함.
4.  이 과정에서 충돌이 없으면 커밋 해시(ID)가 바뀐 새로운 커밋(A', B')이 생성됨.

### 3.4 마무리: Fast-forward 병합

  * Rebase가 끝나면 `topic`은 `main`보다 앞선 위치에 일직선으로 놓이게 됨.
  * `main` 브랜치를 `topic`의 위치로 끌어올려야 함(Fast-forward).


```bash
# 1. main 브랜치로 이동
$ git switch main

# 2. 병합 수행 (일직선이므로 Fast-forward가 됨)
$ git merge topic
```

  * **결과**: 별도의 "Merge branch..." 커밋 없이 깔끔하게 합쳐짐.

-----

## 4\. Rebase 후의 변화 확인

  * **히스토리 확인 명령어**:
    ```bash
    $ git log --graph --oneline --all
    ```
  * **결과 (Linear History)**:
    ```text
    * 9f8g7h (HEAD -> main, topic) B  <-- 최신 커밋
    * 8d7e6f A
    * 6a12b3 2                        <-- 기존 main의 커밋
    * 1a23b4 1
    ```
      * `1 -> 2 -> A -> B` 순서로 일렬로 정렬됨.
      * 그래프상에서 곁가지가 사라짐.

-----

## 5\. 주의사항 (Golden Rule of Rebase)

  * **"이미 공개 저장소(Remote)에 Push한 커밋은 절대 Rebase 하지 말 것\!"**
  * **이유**:
      * Rebase는 커밋의 ID(해시)를 변경해버림.
      * 다른 팀원이 이미 내 코드를 Pull 받아서 작업 중인데 내가 Rebase를 해버리면, 팀원들의 히스토리와 엉켜서 심각한 충돌이 발생함.
  * **언제 쓰는가?**: 나 혼자 작업하는 로컬 브랜치(Feature branch)를 정리해서 메인에 깔끔하게 합치고 싶을 때 사용.

-----

## 6\. 핵심 요약 (Summary)

1.  **Rebase**: 브랜치의 시작점(Base)을 다른 브랜치의 최신 커밋으로 옮기는 작업.
2.  **명령어 순서**:
      * `$ git switch topic` (작업 브랜치로 이동)
      * `$ git rebase main` (메인 브랜치 뒤에 갖다 붙이기)
      * `$ git switch main` -\> `$ git merge topic` (마무리는 Fast-forward 병합)
3.  **결과**: 복잡한 병합 커밋 없이 **깔끔한 한 줄 히스토리** 완성.
4.  **주의**: 혼자 쓰는 브랜치에서만 수행할 것.