# 28. 버전 되돌리기 (Git Reset) 학습 정리

## 1. Reset(리셋) 개요
### 1.1 정의 및 개념
* **Reset**: 특정 커밋 단계로 시간을 되돌리는 기능 ('타임머신' 역할).
* **동작 원리**: 현재 브랜치가 가리키는 포인터(HEAD)를 과거의 특정 커밋으로 이동시킴.
* **주의사항**: 되돌린 시점 이후의 커밋 히스토리는 **삭제**됨 (사라짐).

### 1.2 Reset의 영향 범위 (3가지 영역)
Git의 3가지 영역에 따라 옵션이 달라짐.
1.  **Repository (HEAD)**: `.git` 저장소 (커밋된 상태).
2.  **Staging Area (Index)**: `add` 된 상태.
3.  **Working Directory**: 실제 작업 중인 폴더.

---

## 2. Reset의 3가지 핵심 옵션 (중요!)

| 옵션 (Option) | HEAD 이동 | 스테이징 영역 (Index) | 작업 디렉토리 (Work Tree) | 요약 설명 |
| :--- | :---: | :---: | :---: | :--- |
| **`--soft`** | O (이동) | **유지** (그대로) | **유지** (그대로) | **"커밋만 취소하고 싶을 때"**<br>변경 사항이 `add` 된 상태로 남음. |
| **`--mixed`** | O (이동) | **초기화** (Reset) | **유지** (그대로) | **(기본값) "add까지 취소하고 싶을 때"**<br>변경 사항이 `Unstaged` 상태로 남음. |
| **`--hard`** | O (이동) | **초기화** (Reset) | **초기화** (삭제) | **"완전히 없애버리고 싶을 때"**<br>모든 작업 내용을 날려버림. (주의!) |

> ****
> *(옵션별 영향 범위를 나타내는 다이어그램)*

---

## 3. 상세 실습 및 코드 (Code & Practice)

### 3.1 상황 설정
* 현재 커밋 상태: `A -> B -> C` (HEAD는 C를 가리킴)
* 목표: `C` 커밋을 취소하고 `B` 상태로 돌아가고 싶음.

### 3.2 Soft Reset (`--soft`)
* 커밋은 취소하되, 작업하던 내용은 **스테이징 영역(Staged)**에 남겨둠.
* **언제 쓰는가?**: 커밋 메시지를 다시 작성하거나, 빠진 파일을 추가해서 **다시 커밋**하고 싶을 때.

```bash
# 1. 이전 커밋(HEAD~1)으로 이동하되, 내용은 살려둠 (Staged 상태)
$ git reset --soft HEAD~1

# 2. 상태 확인
$ git status
# 결과: "Changes to be committed" (초록색)
# 파일 내용이 삭제되지 않고 add 된 상태로 남아 있음.

# 3. 바로 다시 커밋 가능
$ git commit -m "수정해서 다시 커밋"
````

### 3.3 Mixed Reset (`--mixed`)

  * **Reset의 기본값(Default)**. 옵션을 안 쓰면 mixed로 동작함.
  * 커밋과 스테이징(`add`)을 모두 취소하지만, **파일 내용은 작업 디렉토리에 그대로** 둠.
  * **언제 쓰는가?**: `add`를 잘못해서 다시 선택적으로 `add` 하고 싶을 때.

<!-- end list -->

```bash
# 1. 이전 커밋으로 이동하고, 스테이징도 해제함
$ git reset --mixed HEAD~1
# 또는
$ git reset HEAD~1

# 2. 상태 확인
$ git status
# 결과: "Changes not staged for commit" (빨간색)
# 파일 내용은 살아있으나 Unstaged(Untracked) 상태가 됨.

# 3. 다시 작업 후 원하는 파일만 add
$ git add file_new.txt
$ git commit -m "다시 커밋"
```

### 3.4 Hard Reset (`--hard`)

  * **가장 강력하고 위험한 옵션.**
  * 커밋, 스테이징, 작업 파일 **모두** 해당 시점으로 되돌려버림 (이후 작업 내용 삭제).
  * **언제 쓰는가?**: 최근 작업이 완전히 망쳐서 그냥 **깔끔하게 과거로 돌아가고 싶을 때**.

<!-- end list -->

```bash
# 1. 뒤도 돌아보지 않고 과거로 복구
$ git reset --hard HEAD~1

# 2. 상태 확인
$ git status
# 결과: "nothing to commit, working tree clean"
# 작업하던 파일 변경 사항이 모두 사라지고, B 커밋 상태와 완벽히 동일해짐.
```

-----

## 4\. Reset vs Checkout 비교

  * 둘 다 무언가를 바꾼다는 점에서 비슷해 보이지만 명확한 차이가 있음.

| 구분 | Reset | Checkout |
| :--- | :--- | :--- |
| **대상** | 주로 \*\*브랜치(Branch)\*\*의 끝을 이동시킴. | 주로 **HEAD** 자체를 이동시킴. |
| **히스토리** | 히스토리를 변경함 (과거로 되감기). | 히스토리를 변경하지 않음 (탐색). |
| **역할** | "이전 상태로 **되돌리기**" (Rollback) | "다른 브랜치로 **이동**" or "파일 복원" |

```bash
# Reset: "main 브랜치야, 너 이제부터 여기(9033)를 가리켜." (이후 커밋 사라짐)
$ git reset 9033

# Checkout: "잠깐 9033 커밋 상태 좀 구경하러 갈게." (돌아올 수 있음)
$ git checkout 9033
```

-----

## 5\. 고급 꿀팁: 실수로 Reset 했을 때 되돌리기

  * `git reset --hard`로 날려버린 커밋을 다시 복구해야 할 때가 있음.
  * **`ORIG_HEAD`**: Reset 명령을 실행하기 직전의 커밋 포인터를 Git이 몰래 저장해두는 변수.

<!-- end list -->

```bash
# 1. 실수로 하드 리셋을 해버림
$ git reset --hard HEAD~1

# (아차! 너무 많이 지웠다!)

# 2. 리셋하기 직전 상태(ORIG_HEAD)로 다시 리셋
$ git reset --hard ORIG_HEAD

# 결과: 방금 지워진 커밋과 파일들이 마법처럼 복구됨.
```

-----

## 6\. 핵심 요약 (Summary)

1.  **`--soft`**: 커밋만 취소 (파일 내용은 **Staged** 유지). -\> **"재커밋 용도"**
2.  **`--mixed`**: 커밋 + `add` 취소 (파일 내용은 **Unstaged** 유지). -\> **"add 다시 하려는 용도"**
3.  **`--hard`**: 커밋 + `add` + 파일 내용 **전부 취소**. -\> **"완전 복구 용도"**
4.  실수로 리셋했다면? `$ git reset --hard ORIG_HEAD`로 살려낼 수 있다.