# 29. [실습] 버전 되돌리기 (Git Reset Practice)

## 1. 실습 개요 (Overview)
* **목표**: 
    1. `git reset`의 3가지 옵션(`soft`, `mixed`, `hard`)을 직접 실습하며 차이를 체감한다.
    2. 파일의 상태 변화(Staged vs Unstaged vs Deleted)를 확인한다.
    3. `Reset`과 `Checkout`의 근본적인 차이점(HEAD 이동 vs 브랜치 이동)을 이해한다.

---

## 2. 실습 환경 준비 (Scenario Setup)
* `Reset`의 효과를 확인하기 위해, **커밋 3개**가 쌓인 상태를 만듭니다.

```bash
# 1. 저장소 초기화
$ git init greset
$ cd greset

# 2. 첫 번째 커밋 (1)
$echo 111 > f$ git add f
$ git commit -m "1"

# 3. 두 번째 커밋 (2)
$echo 222 >> f$ git commit -am "2"

# 4. 세 번째 커밋 (3) - 현재 HEAD 위치
$echo 333 >> f$ git commit -am "3"

# 5. 로그 확인
$ git log --oneline
# (출력 예시)
# 5c1a2b3 (HEAD -> main) 3
# 3b2c1d4 2
# 1a2b3c4 1
````

-----

## 3\. Reset 3대장 상세 실습 (Deep Dive)

### 3.1 Soft Reset (`--soft`)

  * **목적**: "커밋은 취소하고 싶지만, \*\*작업하던 내용은 살려서 바로 다시 커밋(re-commit)\*\*하고 싶을 때"
  * **실습 코드**:
    ```bash
    # 3번 커밋을 취소하고 2번 커밋 상태로 되돌아감 (soft 옵션)
    $ git reset --soft HEAD~1

    # 상태 확인 (중요!)
    $ git status
    # On branch main
    # Changes to be committed:  <-- (초록색 글씨)
    #   modified:   f
    ```
  * **결과 분석**:
      * `HEAD`는 `2`번 커밋으로 이동함.
      * 하지만 `f` 파일의 내용(`333` 추가된 것)은 \*\*스테이징 영역(Index)\*\*에 그대로 남아 있음.
      * `$ git commit`을 입력하면 즉시 다시 커밋 가능.

### 3.2 Mixed Reset (`--mixed`)

  * **목적**: "커밋과 `add`를 모두 취소하고, **파일 수정을 처음부터 다시 검토**하고 싶을 때" (기본값)
  * **실습 코드**:
    ```bash
    # (다시 3번 커밋 상태라고 가정)
    # 3번 커밋을 취소하고 2번으로 돌아가되, 스테이징도 해제함
    $ git reset --mixed HEAD~1
    # 또는 옵션 생략 가능 ($ git reset HEAD~1)

    # 상태 확인 (중요!)
    $ git status
    # On branch main
    # Changes not staged for commit:  <-- (빨간색 글씨)
    #   modified:   f
    ```
  * **결과 분석**:
      * `HEAD`는 `2`번 커밋으로 이동함.
      * 파일 내용(`333`)은 작업 디렉토리에 살아있지만, \*\*`add`가 풀린 상태(Unstaged)\*\*가 됨.
      * 다시 커밋하려면 `$ git add f`부터 해야 함.

### 3.3 Hard Reset (`--hard`)

  * **목적**: "작업 내용이 맘에 안 들어서 **완전히 폐기하고 과거로 돌아갈 때**" (주의\!)
  * **실습 코드**:
    ```bash
    # (다시 3번 커밋 상태라고 가정)
    # 3번 커밋, 스테이징, 파일 수정 내용 모두 날려버림
    $ git reset --hard HEAD~1

    # 상태 확인
    $ git status
    # On branch main
    # nothing to commit, working tree clean

    # 파일 내용 확인
    $ cat f
    # 111
    # 222
    # (333은 흔적도 없이 사라짐)
    ```
  * **결과 분석**:
      * 가장 강력한 초기화. 작업 디렉토리의 파일까지 `2`번 커밋 시점으로 되돌려짐.

-----

## 4\. Reset vs Checkout 비교 (핵심 이론)

  * **공통점**: 특정 커밋 시점의 파일 상태를 볼 수 있다.
  * **차이점**: \*\*"무엇을 움직이는가?"\*\*가 다름.

### 4.1 Git Reset (브랜치를 이동시킴)

  * **개념**: "main 브랜치야, 너는 이제부터 과거의 커밋(`C2`)을 가리켜라."
  * **결과**: 브랜치 자체가 과거로 이동하므로, 그 이후의 커밋들은 히스토리에서 사라짐(Dangling).

<!-- end list -->

```bash
# main 브랜치의 포인터가 9033 커밋으로 이동
$ git reset --hard 9033
```

> **[Graph 변화]**
> `(A) <- (B) <- (C) <- (D: main)`
> **Reset 후:** `(A) <- (B: main) ... (C, D는 삭제됨)`

### 4.2 Git Checkout (HEAD만 이동시킴)

  * **개념**: "브랜치(`main`)는 그대로 두고, \*\*나(HEAD)\*\*만 잠깐 과거(`C2`)를 구경하고 올게."
  * **결과**: `Detached HEAD` 상태가 되며, 기존 브랜치(`main`)는 여전히 최신 커밋을 가리키고 있음. 안전한 시간 여행.

<!-- end list -->

```bash
# HEAD만 9033 커밋으로 이동 (main은 원래 자리에 있음)
$ git checkout 9033
```

> **[Graph 변화]**
> `(A) <- (B) <- (C) <- (D: main)`
> **Checkout 후:** `(A) <- (B: HEAD) <- (C) <- (D: main)`

-----

## 5\. 실습 요약 및 팁 (Summary & Tips)

| 구분 | 명령어 예시 | 스테이징 영역 | 작업 디렉토리 | 용도 |
| :--- | :--- | :--- | :--- | :--- |
| **Soft** | `git reset --soft` | **유지 (Green)** | **유지** | 커밋 메시지 수정, 재커밋 |
| **Mixed** | `git reset --mixed` | **취소 (Red)** | **유지** | add 취소, 부분 재커밋 |
| **Hard** | `git reset --hard` | **삭제** | **삭제** | 완전 복구 (되돌리기) |

> **Tip: 실수로 Hard Reset을 했다면?**
> `$ git reset --hard ORIG_HEAD` 명령어로 리셋하기 바로 직전의 상태로 부활시킬 수 있습니다.