# Git 지역-원격 저장소 브랜치 연동 실습 노트

## 학습 목표

- GitHub에서 원격 저장소를 생성할 수 있다
- 원격 저장소와 연동해 원격 저장소의 수정을 pull할 수 있다
- 원격 저장소와 연동해 원격 저장소의 수정을 fetch한 후 병합할 수 있다
- 원격 저장소와 연동해 지역 저장소의 수정을 push할 수 있다

***

## Git 워크플로우 구조

### 전체 구조도

```
내 컴퓨터 (Local)                          원격 (Remote)
┌─────────────────────────────┐           ┌──────────────────┐
│  Working Directory          │           │ Remote Repository│
│  (.git 폴더가 있는 곳)       │           │  (GitHub)        │
│                             │           │                  │
│  untracked ──git add──→     │           │                  │
│                             │           │                  │
│  Staging Area               │           │                  │
│  (스테이지)                  │           │                  │
│         │                   │           │                  │
│    git commit               │           │                  │
│         ↓                   │           │                  │
│  Local Repository    ─git push→    Remote Repository │
│  (로컬 저장소)        ←git pull─         │
│                      ←git fetch─         │
└─────────────────────────────┘           └──────────────────┘
```

### 파일 상태 변화

- **Untracked** (추적 안 함): Git이 관리하지 않는 새 파일
- **Tracked** (추적 중):
  - **Unmodified** (변경 없음): 수정되지 않은 파일
  - **Modified** (변경함): 수정된 파일
  - **Staged** (스테이지됨): `git add`로 스테이징된 파일

***

## LESSON 01: 원격 저장소 수정 후 지역에서 Pull

### 실습 시나리오

1. 원격 저장소에서 `repo-sync` 생성
2. 지역 저장소에서 원격 저장소 `repo-sync` 복제
3. 원격 저장소에서 파일 `hello.md` 생성
4. 지역 저장소에서 원격 저장소 `repo-sync` pull
5. 원격 저장소에서 파일 `hello.md` 수정
6. 지역 저장소에서 원격 저장소 `repo-sync` fetch
7. 지역 저장소에서 원격 저장소 `origin/main` 병합

***

### 1단계: 원격 저장소 생성

**GitHub에서 새 저장소 생성**
- 저장소 이름: `repo-sync`
- Add a README file 체크
- Public/Private 선택
- Create repository 클릭

***

### 2단계: 지역 저장소에서 원격 저장소 복제

```bash
파이썬@DESKTOP-8TN3J1L MINGW64 /c/[smart git]
$ git clone https://github.com/ai7dnn/repo-sync.git
Cloning into 'repo-sync'
remote: Enumerating objects: 4, done.
remote: Counting objects: 100% (4/4), done.
remote: Compressing objects: 100% (3/3), done.
remote: Total 4 (delta 0), reused 0 (delta 0), pack-reused 0
Receiving objects: 100% (4/4), 12.51 KiB | 3.13 MiB/s, done.
```

**복제된 디렉토리로 이동**
```bash
파이썬@DESKTOP-8TN3J1L MINGW64 /c/[smart git]
$ cd repo-sync
```

**브랜치 확인**
```bash
파이썬@DESKTOP-8TN3J1L MINGW64 /c/[smart git]/repo-sync (main)
$ git branch --all
* main
  remotes/origin/HEAD -> origin/main
  remotes/origin/main
```

#### 분석
- `* main`: 현재 로컬 브랜치
- `remotes/origin/HEAD -> origin/main`: 원격 저장소의 기본 브랜치 포인터
- `remotes/origin/main`: 원격 추적 브랜치

***

### 3단계: 원격 저장소에서 파일 생성

**GitHub 웹 인터페이스에서 `hello.md` 파일 생성**
- Add file → Create new file
- 파일명: `hello.md`
- 내용 작성 후 Commit new file

***

### 4단계: 지역 저장소에서 Pull 실행

```bash
파이썬@DESKTOP-8TN3J1L MINGW64 /c/[smart git]/repo-sync (main)
$ git pull
remote: Enumerating objects: 4, done.
remote: Counting objects: 100% (4/4), done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0
Unpacking objects: 100% (3/3), 726 bytes | 48.00 KiB/s, done.
From https://github.com/ai7dnn/repo-sync
   f8a93b6..b2dbb15  main       -> origin/main
Updating f8a93b6..b2dbb15
Fast-forward
 hello.md | 1 +
 1 file changed, 1 insertion(+)
 create mode 100644 hello.md
```

#### Pull 결과 분석
- `f8a93b6..b2dbb15 main -> origin/main`: 커밋 해시 변화
- `Fast-forward`: 빨리감기 병합 수행
- `hello.md | 1 +`: 1줄 추가
- `create mode 100644 hello.md`: 새 파일 생성

**로컬과 원격 브랜치 차이 확인**
```bash
파이썬@DESKTOP-8TN3J1L MINGW64 /c/[smart git]/repo-sync (main)
$ git diff main origin/main
```
- 출력 없음 → 동기화 완료

**파일 목록 확인**
```bash
파이썬@DESKTOP-8TN3J1L MINGW64 /c/[smart git]/repo-sync (main)
$ ls
LICENSE  README.md  hello.md
```

***

### 5단계: 원격 저장소에서 파일 수정

**GitHub에서 `hello.md` 파일 수정**
- 파일 내용에 `## push와 pull` 추가
- Commit changes

***

### 6단계: 지역 저장소에서 Fetch 실행

```bash
파이썬@DESKTOP-8TN3J1L MINGW64 /c/[smart git]/repo-sync (main)
$ git fetch
remote: Enumerating objects: 5, done.
remote: Counting objects: 100% (5/5), done.
remote: Compressing objects: 100% (3/3), done.
remote: Total 3 (delta 1), reused 0 (delta 0), pack-reused 0
Unpacking objects: 100% (3/3), 691 bytes | 38.00 KiB/s, done.
From https://github.com/ai7dnn/repo-sync
   b2dbb15..21c361e  main       -> origin/main
```

#### Fetch 특징
- 원격 변경사항을 가져오지만 **병합하지 않음**
- `origin/main`만 업데이트, 로컬 `main`은 그대로

**커밋 히스토리 확인**
```bash
파이썬@DESKTOP-8TN3J1L MINGW64 /c/[smart git]/repo-sync (main)
$ git log --oneline --graph --all
* 21c361e (origin/main, origin/HEAD) Update hello.md
* b2dbb15 (HEAD -> main) Create hello.md
* f8a93b6 Initial commit
```

#### 분석
- `21c361e (origin/main, origin/HEAD)`: 원격이 최신 커밋
- `b2dbb15 (HEAD -> main)`: 로컬은 이전 커밋
- **원격이 로컬보다 1커밋 앞서 있음**

**브랜치 간 차이 확인**
```bash
파이썬@DESKTOP-8TN3J1L MINGW64 /c/[smart git]/repo-sync (main)
$ git diff main origin/main
diff --git a/hello.md b/hello.md
index 9def62a..45d287b 100644
--- a/hello.md
+++ b/hello.md
@@ -1 +1,3 @@
 # 지역과 원격 저장소 연동
+
+## push와 pull
```

#### Diff 출력 해석
- `--- a/hello.md`: 로컬 main 브랜치의 파일
- `+++ b/hello.md`: 원격 origin/main 브랜치의 파일
- `@@ -1 +1,3 @@`: 1줄 → 3줄로 변경
- `+`: 추가된 내용 (2줄)

***

### 분리된 HEAD로 브랜치 탐색

#### 현재 상황 파악

**로컬 main 브랜치 파일 내용**
```bash
파이썬@DESKTOP-8TN3J1L MINGW64 /c/[smart git]/repo-sync (main)
$ cat hello.md
# 지역과 원격 저장소 연동
```

**origin/main 브랜치로 이동 (방법 1: checkout)**
```bash
파이썬@DESKTOP-8TN3J1L MINGW64 /c/[smart git]/repo-sync (main)
$ git switch origin/main
fatal: a branch is expected, got remote branch 'origin/main'
hint: If you want to detach HEAD at the commit, try again with the --detach option.
```
- `git switch`는 원격 브랜치로 직접 이동 불가
- `--detach` 옵션 필요

```bash
$ git checkout origin/main
Note: switching to 'origin/main'.

You are in 'detached HEAD' state. You can look around, make experimental

HEAD is now at 21c361e Update hello.md
```

**분리된 HEAD 상태에서 파일 확인**
```bash
파이썬@DESKTOP-8TN3J1L MINGW64 /c/[smart git]/repo-sync ((21c361e...))
$ cat hello.md
# 지역과 원격 저장소 연동

## push와 pull
```
- 원격 브랜치의 내용이 표시됨

**main 브랜치로 복귀**
```bash
파이썬@DESKTOP-8TN3J1L MINGW64 /c/[smart git]/repo-sync ((21c361e...))
$ git checkout main
```

***

### 분리된 HEAD로 이동하는 2가지 방법

#### 방법 1: git checkout
```bash
파이썬@DESKTOP-8TN3J1L MINGW64 /c/[smart git]/repo-sync (main)
$ git checkout origin/main
Note: switching to 'origin/main'.
You are in 'detached HEAD' state.
HEAD is now at 21c361e Update hello.md
```

#### 방법 2: git switch -d
```bash
파이썬@DESKTOP-8TN3J1L MINGW64 /c/[smart git]/repo-sync (main)
$ git log --oneline --graph --all
* 21c361e (origin/main, origin/HEAD) Update hello.md
* b2dbb15 (HEAD -> main) Create hello.md
* f8a93b6 Initial commit
```

```bash
파이썬@DESKTOP-8TN3J1L MINGW64 /c/[smart git]/repo-sync (main)
$ git switch -d origin/main
HEAD is now at 21c361e Update hello.md
```

**분리된 HEAD 상태 확인**
```bash
파이썬@DESKTOP-8TN3J1L MINGW64 /c/[smart git]/repo-sync ((21c361e...))
$ git log --oneline --graph --all
* 21c361e (HEAD, origin/main, origin/HEAD) Update hello.md
* b2dbb15 (main) Create hello.md
* f8a93b6 Initial commit
```
- `HEAD`가 `origin/main`을 직접 가리킴

**main 브랜치로 복귀**
```bash
파이썬@DESKTOP-8TN3J1L MINGW64 /c/[smart git]/repo-sync ((21c361e...))
$ git switch -
Previous HEAD position was 21c361e Update hello.md
Switched to branch 'main'
Your branch is behind 'origin/main' by 1 commit, and can be fast-forwarded.
  (use "git pull" to update your local branch)
```

**복귀 후 상태 확인**
```bash
파이썬@DESKTOP-8TN3J1L MINGW64 /c/[smart git]/repo-sync (main)
$ git log --oneline --graph --all
* 21c361e (origin/main, origin/HEAD) Update hello.md
* b2dbb15 (HEAD -> main) Create hello.md
* f8a93b6 Initial commit
```

***

### 7단계: 원격 브랜치 병합

**병합 전 상태**
```bash
파이썬@DESKTOP-8TN3J1L MINGW64 /c/[smart git]/repo-sync (main)
$ git log --oneline --graph --all
* 21c361e (origin/main, origin/HEAD) Update hello.md
* b2dbb15 (HEAD -> main) Create hello.md
* f8a93b6 Initial commit
```

**병합 실행**
```bash
파이썬@DESKTOP-8TN3J1L MINGW64 /c/[smart git]/repo-sync (main)
$ git merge origin/main
Updating b2dbb15..21c361e
Fast-forward
 hello.md | 2 ++
 1 file changed, 2 insertions(+)
```

#### 병합 결과 분석
- `Fast-forward`: 빨리감기 병합
- `hello.md | 2 ++`: 2줄 추가

**병합 후 상태**
```bash
파이썬@DESKTOP-8TN3J1L MINGW64 /c/[smart git]/repo-sync (main)
$ git log --oneline --graph --all
* 21c361e (HEAD -> main, origin/main, origin/HEAD) Update hello.md
* b2dbb15 Create hello.md
* f8a93b6 Initial commit
```
- `HEAD -> main`, `origin/main`, `origin/HEAD` 모두 동일 위치
- **완전히 동기화됨**

**파일 내용 확인**
```bash
파이썬@DESKTOP-8TN3J1L MINGW64 /c/[smart git]/repo-sync (main)
$ cat hello.md
# 지역과 원격 저장소 연동

## push와 pull
```

**브랜치 차이 확인**
```bash
파이썬@DESKTOP-8TN3J1L MINGW64 /c/[smart git]/repo-sync (main)
$ git diff main origin/main
```
- 출력 없음 → 차이 없음

***

## LESSON 02: 지역에서 원격 저장소로 Push

### 실습 시나리오

1. 지역 저장소에서 `client.md` 파일 생성 후 커밋
2. 지역 저장소에서 원격 저장소로 push 보내기
3. GitHub 원격 저장소에서 확인

***

### 1단계: 지역 저장소에서 파일 생성 및 커밋

**원격 저장소 상태 확인**
```bash
$ git remote show origin
* remote origin
  Fetch URL: https://github.com/ai7dnn/repo-sync.git
  Push  URL: https://github.com/ai7dnn/repo-sync.git
  HEAD branch: main
  Remote branch:
    main tracked
  Local branch configured for 'git pull':
    main merges with remote main
  Local ref configured for 'git push':
    main pushes to main (up to date)
```

#### 분석
- `main pushes to main (up to date)`: 현재 동기화 상태

**새 파일 생성**
```bash
$ echo local repository > client.md
```

**파일 내용 확인**
```bash
$ cat client.md
local repository
```

**스테이징 및 커밋**
```bash
$ git add client.md

$ git commit -m 'add client.md'
[main a4d1d60] add client.md
 1 file changed, 1 insertion(+)
 create mode 100644 client.md
```

**커밋 히스토리 확인**
```bash
$ git log --oneline --graph --all
* a4d1d60 (HEAD -> main) add client.md
* 21c361e (origin/main, origin/HEAD) Update hello.md
* b2dbb15 Create hello.md
* f8a93b6 Initial commit
```

#### 분석
- `a4d1d60 (HEAD -> main)`: 로컬이 최신 커밋
- `21c361e (origin/main, origin/HEAD)`: 원격은 이전 커밋
- **로컬이 원격보다 1커밋 앞서 있음**

**원격 상태 재확인**
```bash
$ git remote show origin
* remote origin
  Fetch URL: https://github.com/ai7dnn/repo-sync.git
  Push  URL: https://github.com/ai7dnn/repo-sync.git
  HEAD branch: main
  Remote branch:
    main tracked
  Local branch configured for 'git pull':
    main merges with remote main
  Local ref configured for 'git push':
    main pushes to main (fast-forwardable)
```

#### 분석
- `main pushes to main (fast-forwardable)`: push 가능 상태
- Fast-forward 방식으로 push 가능

***

### 2단계: 원격 저장소로 Push

**Push 전 상태 확인**
```bash
$ git remote show origin
* remote origin
  Fetch URL: https://github.com/ai7dnn/repo-sync.git
  Push  URL: https://github.com/ai7dnn/repo-sync.git
  HEAD branch: main
  Remote branch:
    main tracked
  Local branch configured for 'git pull':
    main merges with remote main
  Local ref configured for 'git push':
    main pushes to main (fast-forwardable)
```

**로그 확인**
```bash
$ git log --oneline --graph --all
* a4d1d60 (HEAD -> main) add client.md
* 21c361e (origin/main, origin/HEAD) Update hello.md
* b2dbb15 Create hello.md
* f8a93b6 Initial commit
```

**Push 실행**
```bash
$ git push
Enumerating objects: 4, done.
Counting objects: 100% (4/4), done.
Delta compression using up to 12 threads
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 347 bytes | 173.00 KiB/s, done.
Total 3 (delta 0), reused 0 (delta 0), pack-reused 0
To https://github.com/ai7dnn/repo-sync.git
   21c361e..a4d1d60  main -> main
```

#### Push 출력 분석
- `Enumerating objects: 4`: 전송할 객체 4개
- `Counting objects: 100% (4/4)`: 객체 세기 완료
- `Delta compression using up to 12 threads`: 12개 스레드로 압축
- `Compressing objects: 100% (2/2)`: 2개 객체 압축
- `Writing objects: 100% (3/3), 347 bytes`: 3개 객체 전송 (347바이트)
- `21c361e..a4d1d60 main -> main`: 커밋 해시 업데이트

**Push 후 로그 확인**
```bash
$ git log --oneline --graph --all
* a4d1d60 (HEAD -> main, origin/main, origin/HEAD) add client.md
* 21c361e Update hello.md
* b2dbb15 Create hello.md
* f8a93b6 Initial commit
```
- `HEAD -> main`, `origin/main`, `origin/HEAD` 모두 동일 위치
- **완전히 동기화됨**

**원격 상태 최종 확인**
```bash
$ git remote show origin
* remote origin
  Fetch URL: https://github.com/ai7dnn/repo-sync.git
  Push  URL: https://github.com/ai7dnn/repo-sync.git
  HEAD branch: main
  Remote branch:
    main tracked
  Local branch configured for 'git pull':
    main merges with remote main
  Local ref configured for 'git push':
    main pushes to main (up to date)
```
- `main pushes to main (up to date)`: 동기화 완료

***

### Push 인증 방법

#### Browser/Device 인증
- 이미 로그인되어 있으면 바로 수행
- 로그인 안 된 상태면 로그인 화면 표시
- "Sign in with your browser" 선택
- GitHub 계정으로 로그인

#### Token 인증
- Personal Access Token (PAT) 입력
- "Sign in with a code" 선택
- 생성한 PAT 토큰 입력

***

### 3단계: GitHub 원격 저장소 확인

**GitHub 웹 인터페이스에서 확인**
```
ai7dnn / repo-sync Public

main  1 branch  0 tags

ai7dnn  add client.md

LICENSE         Initial commit
README.md       Initial commit
client.md       add client.md
hello.md        Update hello.md
```

- `client.md` 파일이 원격 저장소에 정상 업로드됨
- 커밋 메시지 "add client.md" 표시
- 모든 파일과 커밋 히스토리 동기화 완료

***

## 핵심 명령어 요약

### 원격 저장소 복제
```bash
$ git clone https://github.com/ai7dnn/repo-sync.git
```

### Pull (Fetch + Merge 자동)
```bash
$ git pull origin main
$ git pull
```

### Fetch (병합 없이 가져오기)
```bash
$ git fetch origin main
$ git fetch
```

### Merge (Fetch 후 수동 병합)
```bash
$ git merge origin/main
```

### Push (로컬 → 원격)
```bash
$ git push origin main
$ git push
```

### 브랜치 및 상태 확인
```bash
$ git branch --all                    # 모든 브랜치 목록
$ git log --oneline --graph --all     # 커밋 히스토리 그래프
$ git diff main origin/main           # 브랜치 간 차이
$ git remote show origin              # 원격 저장소 상세 정보
```

### 분리된 HEAD 이동
```bash
$ git checkout origin/main            # 방법 1
$ git switch -d origin/main           # 방법 2
$ git switch -                        # 이전 브랜치로 복귀
```

***

## 주요 학습 포인트

### Pull vs Fetch + Merge

| 구분 | Pull | Fetch + Merge |
|------|------|---------------|
| **명령어** | `git pull` | `git fetch` → `git merge origin/main` |
| **단계** | 1단계 (자동) | 2단계 (수동) |
| **병합** | 자동 병합 | 수동 병합 |
| **검토** | 검토 없음 | 병합 전 검토 가능 |
| **안전성** | 빠르지만 충돌 위험 | 안전하고 제어 가능 |

### 분리된 HEAD (Detached HEAD)

- 원격 브랜치를 직접 체크아웃하면 발생
- 브랜치가 아닌 특정 커밋을 직접 가리킴
- 실험적 작업이나 검토에 유용
- `git checkout origin/main` 또는 `git switch -d origin/main`으로 진입
- `git switch -` 또는 `git checkout main`으로 복귀

### Fast-forward 병합

- 브랜치 간 분기가 없을 때 발생
- 단순히 포인터만 이동
- 병합 커밋 생성 없음
- 깔끔한 히스토리 유지

### 원격 추적 브랜치

- `origin/main`: 원격 저장소의 main 브랜치 추적
- `origin/HEAD`: 원격 저장소의 기본 브랜치 추적
- 로컬 브랜치와 독립적으로 존재
- `git fetch`로만 업데이트됨

***

## 워크플로우 모범 사례

### 안전한 동기화 절차

1. **작업 전 항상 fetch**
   ```bash
   $ git fetch
   ```

2. **변경사항 검토**
   ```bash
   $ git diff main origin/main
   $ git log --oneline --graph --all
   ```

3. **병합 또는 Pull**
   ```bash
   $ git merge origin/main
   # 또는
   $ git pull
   ```

4. **로컬 작업 수행**
   ```bash
   $ git add .
   $ git commit -m "작업 내용"
   ```

5. **Push 전 상태 확인**
   ```bash
   $ git remote show origin
   ```

6. **Push 실행**
   ```bash
   $ git push
   ```
   